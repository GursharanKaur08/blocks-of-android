# Alarm Manager

Daily we used to set Alarms in our phone to wake up in morning or for some meetings, etc. So today we are going to learn about Alarms. Alarms (based on the AlarmManager class) give you a way to perform time-based operations outside the lifetime of your application. For example, you could use an alarm to initiate a long-running operation, such as starting a service once a day to download a weather forecast. You can schedule your application to run at a specific time in the future. It works whether your phone is running or not.

The Alarm Manager holds a CPU wake lock as long as the alarm receiver's onReceive() method is executing. This guarantees that the phone will not sleep until you have finished handling the broadcast. Once onReceive() returns, the Alarm Manager releases this wake lock. This means that the phone will in some cases sleep as soon as your onReceive() method completes. If your alarm receiver called Context.startService(), it is possible that the phone will sleep before the requested service is launched. To prevent this, your BroadcastReceiver and Service will need to implement a separate wake lock policy to ensure that the phone continues running until the service becomes available.

So, how we use it to schedule our tasks?

### Get AlarmManager instance from the system services:
``` kotlin
val alarmMgr = getSystemService(Context.ALARM_SERVICE) as AlarmManager
```

### Create the Intent and PendingIntent to pass in AlarmManager

``` kotlin
// Intent to start the Broadcast Receiver
val broadcastIntent = Intent(this, AlarmBroadcastReceiver::class.java)

// The Pending Intent to pass in AlarmManager
val pIntent = PendingIntent.getBroadcast(this,0,broadcastIntent,0)
```

